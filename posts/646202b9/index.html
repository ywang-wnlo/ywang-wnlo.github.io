<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <meta name="robots" content="noodp" />
    <title>page cache 回写机制 - 乐园</title><meta name="author" content="Zeus">
<meta name="author-link" content="https://github.com/ywang-wnlo">
<meta name="description" content="page cache 回写机制是 Linux 内核中的一个重要的机制，本文主要介绍 page cache 回写机制的策略和源码分析" /><meta name="keywords" content='page cache, buffer IO, kernel, writeback' /><meta itemprop="name" content="page cache 回写机制">
<meta itemprop="description" content="page cache 回写机制是 Linux 内核中的一个重要的机制，本文主要介绍 page cache 回写机制的策略和源码分析"><meta itemprop="datePublished" content="2021-11-19T16:24:30+08:00" />
<meta itemprop="dateModified" content="2022-11-16T10:33:39+08:00" />
<meta itemprop="wordCount" content="7370">
<meta itemprop="keywords" content="page cache,buffer IO,kernel,writeback," /><meta property="og:title" content="page cache 回写机制" />
<meta property="og:description" content="page cache 回写机制是 Linux 内核中的一个重要的机制，本文主要介绍 page cache 回写机制的策略和源码分析" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ywang-wnlo.github.io/posts/646202b9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-19T16:24:30+08:00" />
<meta property="article:modified_time" content="2022-11-16T10:33:39+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="page cache 回写机制"/>
<meta name="twitter:description" content="page cache 回写机制是 Linux 内核中的一个重要的机制，本文主要介绍 page cache 回写机制的策略和源码分析"/>
<meta name="application-name" content="乐园">
<meta name="apple-mobile-web-app-title" content="乐园"><meta name="theme-color" data-light="#f8f8f8" data-dark="#252627" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="canonical" href="https://ywang-wnlo.github.io/posts/646202b9/" /><link rel="prev" href="https://ywang-wnlo.github.io/posts/96a1807/" /><link rel="next" href="https://ywang-wnlo.github.io/posts/4143201a/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://unpkg.com/@fortawesome/fontawesome-free@6.4.2/css/all.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.4.2/css/all.min.css"></noscript><link rel="preload" href="https://unpkg.com/animate.css@4.1.1/animate.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="https://unpkg.com/animate.css@4.1.1/animate.min.css"></noscript><meta name="google-site-verification" content="F3QOKaQRQaSAxN-JLDLGD21CCU5CkZRssZYwX-Mn-Zc" /><meta name="msvalidate.01" content="65AB321A829DD5542989CC078C3ABD9E" /><script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "page cache 回写机制",
    "inLanguage": "zh-CN",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https:\/\/ywang-wnlo.github.io\/posts\/646202b9\/"
    },"genre": "posts","keywords": "page cache, buffer IO, kernel, writeback","wordcount":  7370 ,
    "url": "https:\/\/ywang-wnlo.github.io\/posts\/646202b9\/","datePublished": "2021-11-19T16:24:30+08:00","dateModified": "2022-11-16T10:33:39+08:00","publisher": {
      "@type": "Organization",
      "name": ""},"author": {
        "@type": "Person",
        "name": "Zeus"
      },"description": ""
  }
  </script></head>
  <body data-header-desktop="sticky" data-header-mobile="auto"><script>(window.localStorage?.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('dark' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'dark' === 'dark')) && document.body.setAttribute('data-theme', 'dark');</script><div class="wrapper" data-page-style="normal"><header class="desktop animate__faster" id="header-desktop">
  <div class="header-wrapper">
    <div class="header-title">
      <a href="/" title="乐园"><img loading="lazy" src="/logo.png" alt="乐园" data-title="乐园" class="logo" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/><span class="header-title-text">乐园</span></a><span class="header-subtitle">一个新时代农民工的随手笔记</span></div>
    <nav>
      <ul class="menu"><li class="menu-item">
              <a
                class="menu-link"
                href="/"
                
                
              ><i class="fa fa-home fa-fw fa-sm" aria-hidden="true"></i> 首页</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/tags/"
                
                
              ><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> 标签</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/categories/"
                
                
              ><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden="true"></i> 分类</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/posts/"
                
                
              ><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> 归档</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id="search-desktop">
            <input type="text" placeholder="搜索文章标题或内容……" id="search-input-desktop">
            <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
              <i class="fa-solid fa-search fa-fw" aria-hidden="true"></i>
            </a>
            <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
              <i class="fa-solid fa-times-circle fa-fw" aria-hidden="true"></i>
            </a>
            <span class="search-button search-loading" id="search-loading-desktop">
              <i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
            </span>
          </li><li class="menu-item theme-switch" title="切换主题">
          <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
        </li></ul>
    </nav>
  </div>
</header><header class="mobile animate__faster" id="header-mobile">
  <div class="header-container">
    <div class="header-wrapper">
      <div class="header-title">
        <a href="/" title="乐园"><img loading="lazy" src="/logo.png" alt="/logo.png" data-title="/logo.png" class="logo" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/><span class="header-title-text">乐园</span></a><span class="header-subtitle">一个新时代农民工的随手笔记</span></div>
      <div class="menu-toggle" id="menu-toggle-mobile">
        <span></span><span></span><span></span>
      </div>
    </div>
    <nav>
      <ul class="menu" id="menu-mobile"><li class="search-wrapper">
            <div class="search mobile" id="search-mobile">
              <input type="text" placeholder="搜索文章标题或内容……" id="search-input-mobile">
              <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                <i class="fa-solid fa-search fa-fw" aria-hidden="true"></i>
              </a>
              <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                <i class="fa-solid fa-times-circle fa-fw" aria-hidden="true"></i>
              </a>
              <span class="search-button search-loading" id="search-loading-mobile">
                <i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
              </span>
            </div>
            <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
              取消
            </a>
          </li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/"
                  
                  
                ><i class="fa fa-home fa-fw fa-sm" aria-hidden="true"></i> 首页</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/tags/"
                  
                  
                ><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> 标签</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/categories/"
                  
                  
                ><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden="true"></i> 分类</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/posts/"
                  
                  
                ><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> 归档</a></li><li class="menu-item menu-system">
          <span class="menu-system-item theme-switch" title="切换主题"><i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i></span></li>
      </ul>
    </nav>
  </div>
</header><div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
  </div>
  <div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
  </div><main class="container container-reverse"><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label="合集"></aside>

  <article class="page single">
    <div class="header"><h1 class="single-title animate__animated animate__flipInX"><span>page cache 回写机制</span>
      </h1></div><div class="post-meta">
      <div class="post-meta-line"><span class="post-author"><a href="https://github.com/ywang-wnlo" title="作者"target="_blank" rel="external nofollow noopener noreferrer author" class="author"><img loading="lazy" src="https://www.gravatar.com/avatar/b2c92c9e56f63a626d05dad763973724?s=32&amp;d=" alt="Zeus" data-title="Zeus" class="avatar" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/>&nbsp;Zeus</a></span><span class="post-included-in">&nbsp;收录于 <a href="/categories/io-stack/" class="post-category" title="分类 - IO Stack"><i class="fa-regular fa-folder fa-fw" aria-hidden="true"></i> IO Stack</a></span></div><div class="post-meta-line"><span title="发布于 2021-11-19 16:24:30"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden="true"></i><time datetime="2021-11-19">2021-11-19</time></span>&nbsp;<span title="更新于 2022-11-16 10:33:39"><i class="fa-regular fa-calendar-check fa-fw me-1" aria-hidden="true"></i><time datetime="2022-11-16">2022-11-16</time></span>&nbsp;<span title="7370 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden="true"></i>约 7400 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden="true"></i>预计阅读 15 分钟</span>&nbsp;<span id="busuanzi_container_page_pv" class="busuanzi_visitors comment-visitors" data-flag-title="page cache 回写机制">
              <i class="fa-regular fa-eye fa-fw me-1" aria-hidden="true"></i><span id="busuanzi_value_page_pv">-</span>&nbsp;次阅读
            </span>&nbsp;</div>
    </div><div class="details toc" id="toc-static" data-kept="false">
        <div class="details-summary toc-title">
          <span>目录</span>
          <span><i class="details-icon fa-solid fa-angle-right" aria-hidden="true"></i></span>
        </div>
        <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#writeback-回写">writeback 回写</a></li>
    <li><a href="#相关结构体">相关结构体</a>
      <ul>
        <li><a href="#底层设备信息">底层设备信息</a>
          <ul>
            <li><a href="#初始化">初始化</a></li>
            <li><a href="#部分字段说明">部分字段说明</a></li>
          </ul>
        </li>
        <li><a href="#设备回写管理">设备回写管理</a>
          <ul>
            <li><a href="#初始化-1">初始化</a></li>
            <li><a href="#部分字段说明-1">部分字段说明</a></li>
          </ul>
        </li>
        <li><a href="#回写任务">回写任务</a>
          <ul>
            <li><a href="#部分字段说明-2">部分字段说明</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#回写线程">回写线程</a>
      <ul>
        <li><a href="#初始化-2">初始化</a></li>
        <li><a href="#立即唤醒">立即唤醒</a>
          <ul>
            <li><a href="#wb_wakeup"><code>wb_wakeup</code></a></li>
            <li><a href="#wb_queue_work"><code>wb_queue_work</code></a></li>
          </ul>
        </li>
        <li><a href="#定时唤醒">定时唤醒</a></li>
        <li><a href="#释放销毁">释放销毁</a></li>
      </ul>
    </li>
    <li><a href="#细节分析">细节分析</a>
      <ul>
        <li><a href="#tag-and-write"><code>tag-and-write</code></a></li>
        <li><a href="#range_cyclic"><code>range_cyclic</code></a></li>
        <li><a href="#定期回写">定期回写</a></li>
        <li><a href="#阈值回写">阈值回写</a></li>
      </ul>
    </li>
    <li><a href="#手动触发回写">手动触发回写</a>
      <ul>
        <li><a href="#sync"><code>sync</code></a></li>
        <li><a href="#fsync-和-fdatasync"><code>fsync</code> 和 <code>fdatasync</code></a></li>
        <li><a href="#open-时带有-o_sync"><code>open</code> 时带有 <code>O_SYNC</code></a></li>
      </ul>
    </li>
    <li><a href="#参考资料">参考资料</a></li>
  </ul>
</nav></div>
      </div><div class="content" id="content"><div class="details admonition warning open">
      <div class="details-summary admonition-title">
        <i class="icon fa-solid fa-exclamation-triangle fa-fw" aria-hidden="true"></i>警告<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden="true"></i>
      </div>
      <div class="details-content">
        <div class="admonition-content">本文最后更新于 2022-11-16，文中内容可能已过时。</div>
      </div>
    </div><p>当前内容基于 Linux Kernel <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tag/?h=v5.4.121"target="_blank" rel="external nofollow noopener noreferrer">v5.4.121</a></p>
<h2 id="writeback-回写" class="heading-element">
  <a href="#writeback-%e5%9b%9e%e5%86%99" class="heading-mark"></a>writeback 回写</h2><p>在 <a href="/posts/9ba60726/">page cache 简介</a> 有过介绍</p>
<p>buffer IO 通过 page cache 进行缓存，减少对底层存储设备的直接读写，同时能够提高整体性能</p>
<p>写入到 page cache 的数据不会立刻写入后端设备，而是标记为“脏”，并被加入到脏页链表，后续由内核中的回写进程周期性的将脏页写回到底层存储设备</p>
<p>下面主要分析 page cache 回写机制的策略和实现</p>
<h2 id="相关结构体" class="heading-element">
  <a href="#%e7%9b%b8%e5%85%b3%e7%bb%93%e6%9e%84%e4%bd%93" class="heading-mark"></a>相关结构体</h2><h3 id="底层设备信息" class="heading-element">
  <a href="#%e5%ba%95%e5%b1%82%e8%ae%be%e5%a4%87%e4%bf%a1%e6%81%af" class="heading-mark"></a>底层设备信息</h3><p>在 <code>include/linux/backing-dev-defs.h</code> 中定义了 <code>backing_dev_info</code> 结构体，主要用与记录底层的设备信息</p>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">u64</span> <span class="n">id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">rb_node</span><span class="p">;</span> <span class="cm">/* keyed by -&gt;id */</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">bdi_list</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ra_pages</span><span class="p">;</span>	<span class="cm">/* max readahead in PAGE_SIZE units */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">io_pages</span><span class="p">;</span>	<span class="cm">/* max allowed IO size */</span>
</span></span><span class="line"><span class="cl">	<span class="n">congested_fn</span> <span class="o">*</span><span class="n">congested_fn</span><span class="p">;</span> <span class="cm">/* Function pointer if device is md/dm */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="o">*</span><span class="n">congested_data</span><span class="p">;</span>	<span class="cm">/* Pointer to aux data for congested func */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 通常为 &#34;block&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">kref</span> <span class="n">refcnt</span><span class="p">;</span>	<span class="cm">/* Reference counter for the structure */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">capabilities</span><span class="p">;</span> <span class="cm">/* Device capabilities */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min_ratio</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_ratio</span><span class="p">,</span> <span class="n">max_prop_frac</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * Sum of avg_write_bw of wbs with dirty inodes.  &gt; 0 if there are
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * any dirty wbs, which is depended upon by bdi_has_dirty().
</span></span></span><span class="line"><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">atomic_long_t</span> <span class="n">tot_write_bandwidth</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="n">wb</span><span class="p">;</span>  <span class="cm">/* the root writeback info for this bdi */</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">wb_list</span><span class="p">;</span> <span class="cm">/* list of all wbs */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef CONFIG_CGROUP_WRITEBACK
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>	<span class="k">struct</span> <span class="n">radix_tree_root</span> <span class="n">cgwb_tree</span><span class="p">;</span> <span class="cm">/* radix tree of active cgroup wbs */</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">cgwb_congested_tree</span><span class="p">;</span> <span class="cm">/* their congested states */</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">cgwb_release_mutex</span><span class="p">;</span>  <span class="cm">/* protect shutdown of wb structs */</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="n">wb_switch_rwsem</span><span class="p">;</span> <span class="cm">/* no cgwb switch while syncing */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>	<span class="k">struct</span> <span class="n">bdi_writeback_congested</span> <span class="o">*</span><span class="n">wb_congested</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>	<span class="kt">wait_queue_head_t</span> <span class="n">wb_waitq</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// bdi_class 设备
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 主设备号:次设备号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">char</span> <span class="n">dev_name</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 实际的底层设备
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">laptop_mode_wb_timer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef CONFIG_DEBUG_FS
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debug_dir</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="初始化" class="heading-element">
  <a href="#%e5%88%9d%e5%a7%8b%e5%8c%96" class="heading-mark"></a>初始化</h4><p>该结构体只会由 <code>mm/backing-dev.c</code> 中的 <code>bdi_alloc_node</code> 函数来申请内存空间并调用 <code>bdi_init</code> 初始化</p>
<h4 id="部分字段说明" class="heading-element">
  <a href="#%e9%83%a8%e5%88%86%e5%ad%97%e6%ae%b5%e8%af%b4%e6%98%8e" class="heading-mark"></a>部分字段说明</h4><ol>
<li>
<p><code>name</code> 字段</p>
<p><figure><a class="lightgallery" href="/posts/646202b9/bdi_name.png?size=large" data-thumbnail="/posts/646202b9/bdi_name.png?size=small" data-sub-html="<h2>name 字段</h2><p>name 字段</p>"><img loading="lazy" src="/posts/646202b9/bdi_name.png" alt="name 字段" srcset="/posts/646202b9/bdi_name.png?size=small, /posts/646202b9/bdi_name.png?size=medium 1.5x, /posts/646202b9/bdi_name.png?size=large 2x" sizes="auto" data-title="name 字段" style="--width: 452px;--aspect-ratio: 452 / 159;background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a><figcaption class="image-caption">name 字段</figcaption>
  </figure></p>
<p>在 <code>block/blk-core.c</code> 中 <code>blk_alloc_queue_node</code> 会调用 <code>bdi_alloc_node</code> 来初始化该结构体，其中 <code>name</code> 字段赋值为 <code>&quot;block&quot;</code></p>
</li>
<li>
<p><code>dev</code> 字段</p>
<p>在 <code>mm/backing-dev.c</code> 的 <code>bdi_register_va</code> 会调用 <code>device_create</code> 创建一个 <code>bdi_class</code> 类型的设备，并赋值给 <code>dev</code> 字段</p>
</li>
<li>
<p><code>dev_name</code> 字段</p>
<p>在 <code>mm/backing-dev.c</code> 的 <code>bdi_register_va</code> 还会对 <code>dev_name</code> 进行赋值</p>
<p><figure><a class="lightgallery" href="/posts/646202b9/bdi_dev_name.png?size=large" data-thumbnail="/posts/646202b9/bdi_dev_name.png?size=small" data-sub-html="<h2>dev_name 字段</h2><p>dev_name 字段</p>"><img loading="lazy" src="/posts/646202b9/bdi_dev_name.png" alt="dev_name 字段" srcset="/posts/646202b9/bdi_dev_name.png?size=small, /posts/646202b9/bdi_dev_name.png?size=medium 1.5x, /posts/646202b9/bdi_dev_name.png?size=large 2x" sizes="auto" data-title="dev_name 字段" style="--width: 864px;--aspect-ratio: 864 / 269;background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a><figcaption class="image-caption">dev_name 字段</figcaption>
  </figure></p>
<p>根据调用栈溯源可以发现，<code>mm/backing-dev.c</code> 的 <code>bdi_register_owner</code> 将 <code>fmt</code> 和 <code>args</code> 传递到 <code>bdi_register_va</code>，最终会将主设备号和次设备号拼接组合后进行赋值</p>
</li>
<li>
<p><code>owner</code> 字段</p>
<p>在 <code>mm/backing-dev.c</code> 的 <code>bdi_register_owner</code> 还会对 <code>owner</code> 进行赋值</p>
<p><figure><a class="lightgallery" href="/posts/646202b9/bdi_owner.png?size=large" data-thumbnail="/posts/646202b9/bdi_owner.png?size=small" data-sub-html="<h2>owner 字段</h2><p>owner 字段</p>"><img loading="lazy" src="/posts/646202b9/bdi_owner.png" alt="owner 字段" srcset="/posts/646202b9/bdi_owner.png?size=small, /posts/646202b9/bdi_owner.png?size=medium 1.5x, /posts/646202b9/bdi_owner.png?size=large 2x" sizes="auto" data-title="owner 字段" style="--width: 923px;--aspect-ratio: 923 / 247;background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a><figcaption class="image-caption">owner 字段</figcaption>
  </figure></p>
<p>实际赋值的为 <code>disk</code> 对应的 <code>dev</code>，通过 <code>disk_to_dev</code> 宏转换得到</p>
</li>
</ol>
<h3 id="设备回写管理" class="heading-element">
  <a href="#%e8%ae%be%e5%a4%87%e5%9b%9e%e5%86%99%e7%ae%a1%e7%90%86" class="heading-mark"></a>设备回写管理</h3><p>在 <code>include/linux/backing-dev-defs.h</code> 中定义了 <code>bdi_writeback</code> 结构体，用于管理一个块设备的回写，同时支持 <code>cgroup</code> 进行限制</p>
<div class="highlight" id="id-2"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Each wb (bdi_writeback) can perform writeback operations, is measured
</span></span></span><span class="line"><span class="cl"><span class="cm"> * and throttled, independently.  Without cgroup writeback, each bdi
</span></span></span><span class="line"><span class="cl"><span class="cm"> * (bdi_writeback) is served by its embedded bdi-&gt;wb.
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * On the default hierarchy, blkcg implicitly enables memcg.  This allows
</span></span></span><span class="line"><span class="cl"><span class="cm"> * using memcg&#39;s page ownership for attributing writeback IOs, and every
</span></span></span><span class="line"><span class="cl"><span class="cm"> * memcg - blkcg combination can be served by its own wb by assigning a
</span></span></span><span class="line"><span class="cl"><span class="cm"> * dedicated wb to each memcg, which enables isolation across different
</span></span></span><span class="line"><span class="cl"><span class="cm"> * cgroups and propagation of IO back pressure down from the IO layer upto
</span></span></span><span class="line"><span class="cl"><span class="cm"> * the tasks which are generating the dirty pages to be written back.
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * A cgroup wb is indexed on its bdi by the ID of the associated memcg,
</span></span></span><span class="line"><span class="cl"><span class="cm"> * refcounted with the number of inodes attached to it, and pins the memcg
</span></span></span><span class="line"><span class="cl"><span class="cm"> * and the corresponding blkcg.  As the corresponding blkcg for a memcg may
</span></span></span><span class="line"><span class="cl"><span class="cm"> * change as blkcg is disabled and enabled higher up in the hierarchy, a wb
</span></span></span><span class="line"><span class="cl"><span class="cm"> * is tested for blkcg after lookup and removed from index on mismatch so
</span></span></span><span class="line"><span class="cl"><span class="cm"> * that a new wb for the combination can be created.
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">;</span>	<span class="cm">/* our parent bdi */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">state</span><span class="p">;</span>		<span class="cm">/* Always use atomic bitops on this */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_old_flush</span><span class="p">;</span>	<span class="cm">/* last old data flush */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">b_dirty</span><span class="p">;</span>	<span class="cm">/* dirty inodes */</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">b_io</span><span class="p">;</span>		<span class="cm">/* parked for writeback */</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">b_more_io</span><span class="p">;</span>	<span class="cm">/* parked for more writeback */</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">b_dirty_time</span><span class="p">;</span>	<span class="cm">/* time stamps are dirty */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">spinlock_t</span> <span class="n">list_lock</span><span class="p">;</span>		<span class="cm">/* protects the b_* lists */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">percpu_counter</span> <span class="n">stat</span><span class="p">[</span><span class="n">NR_WB_STAT_ITEMS</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">bdi_writeback_congested</span> <span class="o">*</span><span class="n">congested</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bw_time_stamp</span><span class="p">;</span>	<span class="cm">/* last time write bw is updated */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirtied_stamp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">written_stamp</span><span class="p">;</span>	<span class="cm">/* pages written at bw_time_stamp */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">write_bandwidth</span><span class="p">;</span>	<span class="cm">/* the estimated write bandwidth */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">avg_write_bandwidth</span><span class="p">;</span> <span class="cm">/* further smoothed write bw, &gt; 0 */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * The base dirty throttle rate, re-calculated on every 200ms.
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * All the bdi tasks&#39; dirty rate will be curbed under it.
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * @dirty_ratelimit tracks the estimated @balanced_dirty_ratelimit
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * in small steps and is much more smooth/stable than the latter.
</span></span></span><span class="line"><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirty_ratelimit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">balanced_dirty_ratelimit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">fprop_local_percpu</span> <span class="n">completions</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">dirty_exceeded</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">enum</span> <span class="n">wb_reason</span> <span class="n">start_all_reason</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">spinlock_t</span> <span class="n">work_lock</span><span class="p">;</span>		<span class="cm">/* protects work_list &amp; dwork scheduling */</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">work_list</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">dwork</span><span class="p">;</span>	<span class="cm">/* work item used for writeback */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirty_sleep</span><span class="p">;</span>	<span class="cm">/* last wait */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">bdi_node</span><span class="p">;</span>	<span class="cm">/* anchored at bdi-&gt;wb_list */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef CONFIG_CGROUP_WRITEBACK
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>	<span class="k">struct</span> <span class="n">percpu_ref</span> <span class="n">refcnt</span><span class="p">;</span>	<span class="cm">/* used only for !root wb&#39;s */</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">fprop_local_percpu</span> <span class="n">memcg_completions</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">memcg_css</span><span class="p">;</span> <span class="cm">/* the associated memcg */</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">blkcg_css</span><span class="p">;</span> <span class="cm">/* and blkcg */</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">memcg_node</span><span class="p">;</span>	<span class="cm">/* anchored at memcg-&gt;cgwb_list */</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">blkcg_node</span><span class="p">;</span>	<span class="cm">/* anchored at blkcg-&gt;cgwb_list */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">release_work</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="初始化-1" class="heading-element">
  <a href="#%e5%88%9d%e5%a7%8b%e5%8c%96-1" class="heading-mark"></a>初始化</h4><p>该结构体由 <code>mm/backing-dev.c</code> 中的 <code>wb_init</code> 函数初始化</p>
<div class="mermaid" id="id-3"></div><h4 id="部分字段说明-1" class="heading-element">
  <a href="#%e9%83%a8%e5%88%86%e5%ad%97%e6%ae%b5%e8%af%b4%e6%98%8e-1" class="heading-mark"></a>部分字段说明</h4><ol>
<li>
<p><code>b_dirty</code> 字段</p>
<p>暂存所有的脏 inode 的链表</p>
</li>
<li>
<p><code>b_io</code> 字段</p>
<p>暂存即将回写的 inode 的链表</p>
</li>
<li>
<p><code>b_more_io</code> 字段</p>
<p>暂存由于一次回写数量限制原因导致的等待下次回写的 inode 链表</p>
</li>
<li>
<p><code>b_dirty_time</code> 字段</p>
<p>暂存仅仅是时间戳更新而被至脏的 inode 的链表</p>
</li>
<li>
<p><code>list_lock</code> 字段</p>
<p>为了保护上述 4 个 <code>b_*</code> 列表的自旋锁</p>
</li>
<li>
<p><code>dwork</code> 字段</p>
<p>用于 page cache 回写机制的 <code>work</code> 关键结构体</p>
</li>
<li>
<p><code>work_list</code> 字段</p>
<p>暂存所有需要回写的任务的链表</p>
</li>
<li>
<p><code>work_lock</code> 字段</p>
<p>为了保护 <code>work_list</code> 以及 <code>dwork</code> 调度的自旋锁</p>
</li>
</ol>
<h3 id="回写任务" class="heading-element">
  <a href="#%e5%9b%9e%e5%86%99%e4%bb%bb%e5%8a%a1" class="heading-mark"></a>回写任务</h3><p>在 <code>fs/fs-writeback.c</code> 中定义了 <code>wb_writeback_work</code> 结构体，用于描述一次回写任务的相关参数</p>
<div class="highlight" id="id-4"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Passed into wb_writeback(), essentially a subset of writeback_control
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">wb_writeback_work</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 本次回写的页数限制
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">long</span> <span class="n">nr_pages</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 回写的文件系统的超级块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 回写的模式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">enum</span> <span class="n">writeback_sync_modes</span> <span class="n">sync_mode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// tag-and-write 机制标记
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">tagged_writepages</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 定期回写标记
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">for_kupdate</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 继续上次循环回写标记
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">range_cyclic</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 阈值回写标记
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">for_background</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// sync 系统调用标记
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">for_sync</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* sync(2) WB_SYNC_ALL writeback */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">auto_free</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* free on completion */</span>
</span></span><span class="line"><span class="cl">	<span class="k">enum</span> <span class="n">wb_reason</span> <span class="n">reason</span><span class="p">;</span>		<span class="cm">/* why was writeback initiated? */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>		<span class="cm">/* pending work list */</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">wb_completion</span> <span class="o">*</span><span class="n">done</span><span class="p">;</span>	<span class="cm">/* set if the caller waits */</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>后续通过 <code>include/linux/writeback.h</code> 中的 <code>writeback_control</code> 结构体封装，传递给底层的 <code>writepages</code> 函数</p>
<div class="highlight" id="id-5"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm"> * A control structure which tells the writeback code what to do.  These are
</span></span></span><span class="line"><span class="cl"><span class="cm"> * always on the stack, and hence need no locking.  They are always initialised
</span></span></span><span class="line"><span class="cl"><span class="cm"> * in a manner such that unspecified fields are set to zero.
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">writeback_control</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">long</span> <span class="n">nr_to_write</span><span class="p">;</span>		<span class="cm">/* Write this many pages, and decrement
</span></span></span><span class="line"><span class="cl"><span class="cm">					   this for each page written */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">long</span> <span class="n">pages_skipped</span><span class="p">;</span>		<span class="cm">/* Pages which were not written */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * For a_ops-&gt;writepages(): if start or end are non-zero then this is
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * a hint that the filesystem need only write out the pages inside that
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * byterange.  The byte at `end&#39; is included in the writeout request.
</span></span></span><span class="line"><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">loff_t</span> <span class="n">range_start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">loff_t</span> <span class="n">range_end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">enum</span> <span class="n">writeback_sync_modes</span> <span class="n">sync_mode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="nl">for_kupdate</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* A kupdate writeback */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="nl">for_background</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* A background writeback */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="nl">tagged_writepages</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* tag-and-write to avoid livelock */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="nl">for_reclaim</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* Invoked from the page allocator */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="nl">range_cyclic</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* range_start is cyclic */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="nl">for_sync</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* sync(2) WB_SYNC_ALL writeback */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * When writeback IOs are bounced through async layers, only the
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * initial synchronous phase should be accounted towards inode
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * cgroup ownership arbitration to avoid confusion.  Later stages
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * can set the following flag to disable the accounting.
</span></span></span><span class="line"><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="nl">no_cgroup_owner</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="nl">punt_to_cgroup</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* cgrp punting, see __REQ_CGROUP_PUNT */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef CONFIG_CGROUP_WRITEBACK
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>	<span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">wb</span><span class="p">;</span>	<span class="cm">/* wb this writeback is issued under */</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>		<span class="cm">/* inode being written out */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/* foreign inode detection, see wbc_detach_inode() */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">wb_id</span><span class="p">;</span>			<span class="cm">/* current wb id */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">wb_lcand_id</span><span class="p">;</span>		<span class="cm">/* last foreign candidate wb id */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">wb_tcand_id</span><span class="p">;</span>		<span class="cm">/* this foreign candidate wb id */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">size_t</span> <span class="n">wb_bytes</span><span class="p">;</span>		<span class="cm">/* bytes written by current wb */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">size_t</span> <span class="n">wb_lcand_bytes</span><span class="p">;</span>		<span class="cm">/* bytes written by last candidate */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">size_t</span> <span class="n">wb_tcand_bytes</span><span class="p">;</span>		<span class="cm">/* bytes written by this candidate */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="部分字段说明-2" class="heading-element">
  <a href="#%e9%83%a8%e5%88%86%e5%ad%97%e6%ae%b5%e8%af%b4%e6%98%8e-2" class="heading-mark"></a>部分字段说明</h4><ol>
<li>
<p><code>sync_mode</code> 字段</p>
<p><code>WB_SYNC_NONE</code>：绝大部分回写任务的配置，不会等待回写真正落盘，下发写命令后就返回</p>
<p><code>WB_SYNC_ALL</code>：<code>sync</code> 系统调用时配置，必须等待回调函数执行完成，写的数据真正落盘之后才会返回</p>
</li>
<li>
<p><code>tagged_writepages</code> 字段</p>
<p>值为 1 表示开启 <code>tag-and-write</code> 机制用于避免活锁。该机制详情参考 <a href="#tag-and-write">后续小节</a></p>
</li>
<li>
<p><code>for_kupdate</code> 字段</p>
<p>值为 1 表示当前任务是定期回写任务，用于回写已经至脏超过指定时间（内核中当前配置为 30s）的脏页。定期回写详情参考 <a href="#%e5%ae%9a%e6%9c%9f%e5%9b%9e%e5%86%99">后续小节</a></p>
</li>
<li>
<p><code>range_cyclic</code> 字段</p>
<p>值为 1 表示当前任务的回写范围为整个 <code>inode</code>，并且从上次完成的位置作为起始位置进行循环回写。值为 0 则根据 <code>struct writeback_control wbc</code> 的 <code>range_start</code> 以及 <code>range_end</code> 作为回写的范围。<code>range_cyclic</code> 的详情参考 <a href="#range_cyclic">后续小节</a></p>
</li>
<li>
<p><code>for_background</code> 字段</p>
<p>值为 1 表示当前任务是阈值回写任务，当脏页比例超过阈值后才会触发。阈值回写详情参考 <a href="#%e9%98%88%e5%80%bc%e5%9b%9e%e5%86%99">后续小节</a></p>
</li>
<li>
<p><code>for_sync</code> 字段</p>
<p>值为 1 表示当前任务是阈值回写任务 <code>sync</code> 系统调用手动触发的回写任务。<code>sync</code> 系统调用详情参考 <a href="#sync">后续小节</a></p>
</li>
</ol>
<h2 id="回写线程" class="heading-element">
  <a href="#%e5%9b%9e%e5%86%99%e7%ba%bf%e7%a8%8b" class="heading-mark"></a>回写线程</h2><p>前面说过 <code>bdi_writeback</code> 结构体中 <code>struct delayed_work dwork</code> 就是关键的负责 page cache 回写工作的结构体</p>
<h3 id="初始化-2" class="heading-element">
  <a href="#%e5%88%9d%e5%a7%8b%e5%8c%96-2" class="heading-mark"></a>初始化</h3><p><code>wb_init</code> 函数会对 <code>wb-&gt;dwork</code> 赋值，注册实际的工作函数 <code>wb_workfn</code></p>
<p>由于这是个 <code>delayed_work</code>，注册的工作函数不会立即执行，需要后续利用 <code>mod_delayed_work</code> 来修改 <code>delayed_work</code> 内置的定时器时间来唤醒</p>
<p><figure><a class="lightgallery" href="/posts/646202b9/wb_init.png?size=large" data-thumbnail="/posts/646202b9/wb_init.png?size=small" data-sub-html="<h2>wb_init 调用图</h2><p>wb_init 调用图</p>"><img loading="lazy" src="/posts/646202b9/wb_init.png" alt="wb_init 调用图" srcset="/posts/646202b9/wb_init.png?size=small, /posts/646202b9/wb_init.png?size=medium 1.5x, /posts/646202b9/wb_init.png?size=large 2x" sizes="auto" data-title="wb_init 调用图" style="--width: 1281px;--aspect-ratio: 1281 / 795;background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a><figcaption class="image-caption">wb_init 调用图</figcaption>
  </figure></p>
<p>(P.S. 图片中函数开头为 <code>cg</code> 代表和 <code>cgroup</code> 相关，同一层级多个同名函数和宏定义的编译控制有关)</p>
<p>根据函数调用图，大致分析可知，当设备申请 <code>queue</code> 时会初始化 <code>backing_dev_info</code> 结构体和 <code>bdi_writeback</code> 结构体，以及初始化回写线程</p>
<h3 id="立即唤醒" class="heading-element">
  <a href="#%e7%ab%8b%e5%8d%b3%e5%94%a4%e9%86%92" class="heading-mark"></a>立即唤醒</h3><p>虽然 <code>dwork</code> 是个 <code>delayed_work</code>，但是我们可以在调用 <code>mod_delayed_work</code> 将延时设置为 0，来立即唤醒回写线程</p>
<p><figure><a class="lightgallery" href="/posts/646202b9/dwork_callers.png?size=large" data-thumbnail="/posts/646202b9/dwork_callers.png?size=small" data-sub-html="<h2>dwork 调用图</h2><p>dwork 调用图</p>"><img loading="lazy" src="/posts/646202b9/dwork_callers.png" alt="dwork 调用图" srcset="/posts/646202b9/dwork_callers.png?size=small, /posts/646202b9/dwork_callers.png?size=medium 1.5x, /posts/646202b9/dwork_callers.png?size=large 2x" sizes="auto" data-title="dwork 调用图" style="--width: 408px;--aspect-ratio: 408 / 233;background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a><figcaption class="image-caption">dwork 调用图</figcaption>
  </figure></p>
<h4 id="wb_wakeup" class="heading-element">
  <a href="#wb_wakeup" class="heading-mark"></a><code>wb_wakeup</code></h4><p><code>wb_wakeup</code> 就是修改延时为 0，直接唤醒回写线程</p>
<div class="highlight" id="id-6"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// fs/fs-writeback.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">wb_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">wb</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">work_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">test_bit</span><span class="p">(</span><span class="n">WB_registered</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nf">mod_delayed_work</span><span class="p">(</span><span class="n">bdi_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">dwork</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">work_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="wb_queue_work" class="heading-element">
  <a href="#wb_queue_work" class="heading-mark"></a><code>wb_queue_work</code></h4><p><code>wb_queue_work</code> 将一个回写任务插入到队列尾部，然后修改延时为 0，立即唤醒回写线程</p>
<div class="highlight" id="id-7"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// fs/fs-writeback.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">wb_queue_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">wb</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			  <span class="k">struct</span> <span class="n">wb_writeback_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">trace_writeback_queue</span><span class="p">(</span><span class="n">wb</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nf">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">done</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">work_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">test_bit</span><span class="p">(</span><span class="n">WB_registered</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="nf">mod_delayed_work</span><span class="p">(</span><span class="n">bdi_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">dwork</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span>
</span></span><span class="line"><span class="cl">		<span class="nf">finish_writeback_work</span><span class="p">(</span><span class="n">wb</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">work_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="定时唤醒" class="heading-element">
  <a href="#%e5%ae%9a%e6%97%b6%e5%94%a4%e9%86%92" class="heading-mark"></a>定时唤醒</h3><p>定时唤醒主要是由 <code>wb_wakeup_delayed</code> 来实现的，而时间间隔在 <code>mm/page-writeback.c</code> 进行了定义</p>
<div class="highlight" id="id-8"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// mm/page-writeback.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm"> * The interval between `kupdate&#39;-style writebacks
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dirty_writeback_interval</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="mi">100</span><span class="p">;</span> <span class="cm">/* centiseconds */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dirty_writeback_interval</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight" id="id-9"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// mm/backing-dev.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm"> * This function is used when the first inode for this wb is marked dirty. It
</span></span></span><span class="line"><span class="cl"><span class="cm"> * wakes-up the corresponding bdi thread which should then take care of the
</span></span></span><span class="line"><span class="cl"><span class="cm"> * periodic background write-out of dirty inodes. Since the write-out would
</span></span></span><span class="line"><span class="cl"><span class="cm"> * starts only &#39;dirty_writeback_interval&#39; centisecs from now anyway, we just
</span></span></span><span class="line"><span class="cl"><span class="cm"> * set up a timer which wakes the bdi thread up later.
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Note, we wouldn&#39;t bother setting up the timer, but this function is on the
</span></span></span><span class="line"><span class="cl"><span class="cm"> * fast-path (used by &#39;__mark_inode_dirty()&#39;), so we save few context switches
</span></span></span><span class="line"><span class="cl"><span class="cm"> * by delaying the wake-up.
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * We have to be careful not to postpone flush work if it is scheduled for
</span></span></span><span class="line"><span class="cl"><span class="cm"> * earlier. Thus we use queue_delayed_work().
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">wb_wakeup_delayed</span><span class="p">(</span><span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">wb</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">timeout</span> <span class="o">=</span> <span class="nf">msecs_to_jiffies</span><span class="p">(</span><span class="n">dirty_writeback_interval</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">work_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">test_bit</span><span class="p">(</span><span class="n">WB_registered</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nf">queue_delayed_work</span><span class="p">(</span><span class="n">bdi_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">dwork</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">work_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>wb_wakeup_delayed</code> 使用 5s 作为时间间隔，当调用 <code>wb_wakeup_delayed</code> 后，回写线程会在 5s 后被唤醒</p>
<p><figure><a class="lightgallery" href="/posts/646202b9/wb_wakeup_delayed.png?size=large" data-thumbnail="/posts/646202b9/wb_wakeup_delayed.png?size=small" data-sub-html="<h2>wb_wakeup_delayed 调用图</h2><p>wb_wakeup_delayed 调用图</p>"><img loading="lazy" src="/posts/646202b9/wb_wakeup_delayed.png" alt="wb_wakeup_delayed 调用图" srcset="/posts/646202b9/wb_wakeup_delayed.png?size=small, /posts/646202b9/wb_wakeup_delayed.png?size=medium 1.5x, /posts/646202b9/wb_wakeup_delayed.png?size=large 2x" sizes="auto" data-title="wb_wakeup_delayed 调用图" style="--width: 385px;--aspect-ratio: 385 / 100;background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a><figcaption class="image-caption">wb_wakeup_delayed 调用图</figcaption>
  </figure></p>
<p>定时唤醒只会在两种情形下被调用：</p>
<ul>
<li><code>__mark_inode_dirty</code>：当给一个 <code>inode</code> 标记为脏时，如果脏的不仅仅是时间戳，而且当前的 <code>b_dirty</code> 链表是空的，也就是说第一次将脏页挂在 <code>b_dirty</code> 链表时，开启定时唤醒</li>
<li><code>wb_workfn</code>：当回写线程处理完 <code>work_list</code> 上的所有任务后，如果仍有脏 <code>inode</code> 在 <code>b_{dirty|io|more_io}</code> 上时，开启定时唤醒</li>
</ul>
<p>简单的讲，就是只要存在脏 <code>inode</code> 在 <code>b_{dirty|io|more_io}</code> 上时，内核的回写线程每 5s 内肯定会被唤醒一次</p>
<h3 id="释放销毁" class="heading-element">
  <a href="#%e9%87%8a%e6%94%be%e9%94%80%e6%af%81" class="heading-mark"></a>释放销毁</h3><p><figure><a class="lightgallery" href="/posts/646202b9/release_bdi.png?size=large" data-thumbnail="/posts/646202b9/release_bdi.png?size=small" data-sub-html="<h2>release_bdi 调用图</h2><p>release_bdi 调用图</p>"><img loading="lazy" src="/posts/646202b9/release_bdi.png" alt="release_bdi 调用图" srcset="/posts/646202b9/release_bdi.png?size=small, /posts/646202b9/release_bdi.png?size=medium 1.5x, /posts/646202b9/release_bdi.png?size=large 2x" sizes="auto" data-title="release_bdi 调用图" style="--width: 634px;--aspect-ratio: 634 / 283;background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a><figcaption class="image-caption">release_bdi 调用图</figcaption>
  </figure></p>
<p>当需要对整个 <code>backing_dev_info</code> 结构释放时，也会立即唤醒内核回写线程，并且会下刷现有的所有工作</p>
<div class="mermaid" id="id-10"></div><h2 id="细节分析" class="heading-element">
  <a href="#%e7%bb%86%e8%8a%82%e5%88%86%e6%9e%90" class="heading-mark"></a>细节分析</h2><h3 id="tag-and-write" class="heading-element">
  <a href="#tag-and-write" class="heading-mark"></a><code>tag-and-write</code></h3><p>该机制会在 <code>write_pages</code> 时先快速对下刷范围内的脏页进行标记，后续只对标记过的脏页进行下刷</p>
<p>首先回写任务的参数会通过 <code>fs/fs-writeback.c</code> 的 <code>writeback_sb_inodes</code> 函数传递给 <code>struct writeback_control wbc</code></p>
<p>后续在 <code>mm/page-writeback.c</code> 中 <code>write_cache_pages</code> 就会根据 <code>wbc</code> 的 <code>tagged_writepages</code> 字段进行判断，配置不同的 <code>tag</code>，以及是否需要快速遍历脏页并标记</p>
<div class="highlight" id="id-11"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * write_cache_pages - walk the list of dirty pages of the given address space and write all of them.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @mapping: address space structure to write
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @wbc: subtract the number of written pages from *@wbc-&gt;nr_to_write
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @writepage: function called for each page
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @data: data passed to writepage function
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * If a page is already under I/O, write_cache_pages() skips it, even
</span></span></span><span class="line"><span class="cl"><span class="cm"> * if it&#39;s dirty.  This is desirable behaviour for memory-cleaning writeback,
</span></span></span><span class="line"><span class="cl"><span class="cm"> * but it is INCORRECT for data-integrity system calls such as fsync().  fsync()
</span></span></span><span class="line"><span class="cl"><span class="cm"> * and msync() need to guarantee that all the data which was dirty at the time
</span></span></span><span class="line"><span class="cl"><span class="cm"> * the call was made get new I/O started against them.  If wbc-&gt;sync_mode is
</span></span></span><span class="line"><span class="cl"><span class="cm"> * WB_SYNC_ALL then we were called for data integrity and we must wait for
</span></span></span><span class="line"><span class="cl"><span class="cm"> * existing IO to complete.
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * To avoid livelocks (when other process dirties new pages), we first tag
</span></span></span><span class="line"><span class="cl"><span class="cm"> * pages which should be written back with TOWRITE tag and only then start
</span></span></span><span class="line"><span class="cl"><span class="cm"> * writing them. For data-integrity sync we have to be careful so that we do
</span></span></span><span class="line"><span class="cl"><span class="cm"> * not miss some pages (e.g., because some other process has cleared TOWRITE
</span></span></span><span class="line"><span class="cl"><span class="cm"> * tag we set). The rule we follow is that TOWRITE tag can be cleared only
</span></span></span><span class="line"><span class="cl"><span class="cm"> * by the process clearing the DIRTY tag (and submitting the page for IO).
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * To avoid deadlocks between range_cyclic writeback and callers that hold
</span></span></span><span class="line"><span class="cl"><span class="cm"> * pages in PageWriteback to aggregate IO until write_cache_pages() returns,
</span></span></span><span class="line"><span class="cl"><span class="cm"> * we do not loop back to the start of the file. Doing so causes a page
</span></span></span><span class="line"><span class="cl"><span class="cm"> * lock/page writeback access order inversion - we should only ever lock
</span></span></span><span class="line"><span class="cl"><span class="cm"> * multiple pages in ascending page-&gt;index order, and looping back to the start
</span></span></span><span class="line"><span class="cl"><span class="cm"> * of the file violates that rule and causes deadlocks.
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Return: %0 on success, negative error code otherwise
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">write_cache_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		      <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">,</span> <span class="kt">writepage_t</span> <span class="n">writepage</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		      <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">pagevec</span> <span class="n">pvec</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">nr_pages</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">pgoff_t</span> <span class="nf">uninitialized_var</span><span class="p">(</span><span class="n">writeback_index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="kt">pgoff_t</span> <span class="n">index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">pgoff_t</span> <span class="n">end</span><span class="p">;</span>		<span class="cm">/* Inclusive */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">pgoff_t</span> <span class="n">done_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">range_whole</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">xa_mark_t</span> <span class="n">tag</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">pagevec_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_cyclic</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">writeback_index</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">writeback_index</span><span class="p">;</span> <span class="cm">/* prev offset */</span>
</span></span><span class="line"><span class="cl">		<span class="n">index</span> <span class="o">=</span> <span class="n">writeback_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">end</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">index</span> <span class="o">=</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">end</span> <span class="o">=</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_end</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_start</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_end</span> <span class="o">==</span> <span class="n">LLONG_MAX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="n">range_whole</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">WB_SYNC_ALL</span> <span class="o">||</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">tagged_writepages</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">tag</span> <span class="o">=</span> <span class="n">PAGECACHE_TAG_TOWRITE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">else</span>
</span></span><span class="line"><span class="cl">		<span class="n">tag</span> <span class="o">=</span> <span class="n">PAGECACHE_TAG_DIRTY</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">WB_SYNC_ALL</span> <span class="o">||</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">tagged_writepages</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nf">tag_pages_for_writeback</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">done_index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">nr_pages</span> <span class="o">=</span> <span class="nf">pagevec_lookup_range_tag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">				<span class="n">tag</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pvec</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="n">done_index</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="nf">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">			 * Page truncated or invalidated. We can freely skip it
</span></span></span><span class="line"><span class="cl"><span class="cm">			 * then, even for data integrity operations: the page
</span></span></span><span class="line"><span class="cl"><span class="cm">			 * has disappeared concurrently, so there could be no
</span></span></span><span class="line"><span class="cl"><span class="cm">			 * real expectation of this data interity operation
</span></span></span><span class="line"><span class="cl"><span class="cm">			 * even if there is now a new, dirty page at the same
</span></span></span><span class="line"><span class="cl"><span class="cm">			 * pagecache address.
</span></span></span><span class="line"><span class="cl"><span class="cm">			 */</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">!=</span> <span class="n">mapping</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nl">continue_unlock</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="nf">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">				<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="cm">/* someone wrote it for us */</span>
</span></span><span class="line"><span class="cl">				<span class="k">goto</span> <span class="n">continue_unlock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="nf">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">!=</span> <span class="n">WB_SYNC_NONE</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="nf">wait_on_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">				<span class="k">else</span>
</span></span><span class="line"><span class="cl">					<span class="k">goto</span> <span class="n">continue_unlock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="nf">BUG_ON</span><span class="p">(</span><span class="nf">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">clear_page_dirty_for_io</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">				<span class="k">goto</span> <span class="n">continue_unlock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="nf">trace_wbc_writepage</span><span class="p">(</span><span class="n">wbc</span><span class="p">,</span> <span class="nf">inode_to_bdi</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">			<span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">writepage</span><span class="p">)(</span><span class="n">page</span><span class="p">,</span> <span class="n">wbc</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">				 * Handle errors according to the type of
</span></span></span><span class="line"><span class="cl"><span class="cm">				 * writeback. There&#39;s no need to continue for
</span></span></span><span class="line"><span class="cl"><span class="cm">				 * background writeback. Just push done_index
</span></span></span><span class="line"><span class="cl"><span class="cm">				 * past this page so media errors won&#39;t choke
</span></span></span><span class="line"><span class="cl"><span class="cm">				 * writeout for the entire file. For integrity
</span></span></span><span class="line"><span class="cl"><span class="cm">				 * writeback, we must process the entire dirty
</span></span></span><span class="line"><span class="cl"><span class="cm">				 * set regardless of errors because the fs may
</span></span></span><span class="line"><span class="cl"><span class="cm">				 * still have state to clear for each page. In
</span></span></span><span class="line"><span class="cl"><span class="cm">				 * that case we continue processing and return
</span></span></span><span class="line"><span class="cl"><span class="cm">				 * the first error.
</span></span></span><span class="line"><span class="cl"><span class="cm">				 */</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="n">AOP_WRITEPAGE_ACTIVATE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nf">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">					<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">!=</span> <span class="n">WB_SYNC_ALL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="n">ret</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">					<span class="n">done_index</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">					<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">					<span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="n">ret</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">			 * We stop writing back only if we are not doing
</span></span></span><span class="line"><span class="cl"><span class="cm">			 * integrity sync. In case of integrity sync we have to
</span></span></span><span class="line"><span class="cl"><span class="cm">			 * keep going until we have written all the pages
</span></span></span><span class="line"><span class="cl"><span class="cm">			 * we tagged for writeback prior to entering this loop.
</span></span></span><span class="line"><span class="cl"><span class="cm">			 */</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">nr_to_write</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">			    <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">WB_SYNC_NONE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">				<span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nf">pagevec_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="nf">cond_resched</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * If we hit the last page and there is more work to be done: wrap
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * back the index back to the start of the file for the next
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * time we are called.
</span></span></span><span class="line"><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_cyclic</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">done</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">done_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_cyclic</span> <span class="o">||</span> <span class="p">(</span><span class="n">range_whole</span> <span class="o">&amp;&amp;</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">nr_to_write</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">writeback_index</span> <span class="o">=</span> <span class="n">done_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nf">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">write_cache_pages</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在 <code>fs/fs-writeback.c</code> 中 <code>writeback_chunk_size</code> 里面的注释也对这个流程进行了描述</p>
<div class="highlight" id="id-12"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">long</span> <span class="nf">writeback_chunk_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">wb</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">				 <span class="k">struct</span> <span class="n">wb_writeback_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">long</span> <span class="n">pages</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * WB_SYNC_ALL mode does livelock avoidance by syncing dirty
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * inodes/pages in one big loop. Setting wbc.nr_to_write=LONG_MAX
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * here avoids calling into writeback_inodes_wb() more than once.
</span></span></span><span class="line"><span class="cl"><span class="cm">	 *
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * The intended call sequence for WB_SYNC_ALL writeback is:
</span></span></span><span class="line"><span class="cl"><span class="cm">	 *
</span></span></span><span class="line"><span class="cl"><span class="cm">	 *      wb_writeback()
</span></span></span><span class="line"><span class="cl"><span class="cm">	 *          writeback_sb_inodes()       &lt;== called only once
</span></span></span><span class="line"><span class="cl"><span class="cm">	 *              write_cache_pages()     &lt;== called once for each inode
</span></span></span><span class="line"><span class="cl"><span class="cm">	 *                   (quickly) tag currently dirty pages
</span></span></span><span class="line"><span class="cl"><span class="cm">	 *                   (maybe slowly) sync all tagged pages
</span></span></span><span class="line"><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">WB_SYNC_ALL</span> <span class="o">||</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">tagged_writepages</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">pages</span> <span class="o">=</span> <span class="n">LONG_MAX</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">pages</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">avg_write_bandwidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			    <span class="n">global_wb_domain</span><span class="p">.</span><span class="n">dirty_limit</span> <span class="o">/</span> <span class="n">DIRTY_SCOPE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">pages</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">pages</span> <span class="o">=</span> <span class="nf">round_down</span><span class="p">(</span><span class="n">pages</span> <span class="o">+</span> <span class="n">MIN_WRITEBACK_PAGES</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">				   <span class="n">MIN_WRITEBACK_PAGES</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">pages</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="range_cyclic" class="heading-element">
  <a href="#range_cyclic" class="heading-mark"></a><code>range_cyclic</code></h3><p><code>range_cyclic</code> 早在内核的 v2.6.18-rc1 版本就已经实现，可以参考 <a href="https://github.com/torvalds/linux/commit/111ebb6e6f7bd7de6d722c5848e95621f43700d9"target="_blank" rel="external nofollow noopener noreferrer">111ebb6</a> 的提交信息辅助理解</p>
<div class="highlight" id="id-13"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[PATCH] writeback: fix range handling
</span></span><span class="line"><span class="cl">When a writeback_control&#39;s `start&#39; and `end&#39; fields are used to
</span></span><span class="line"><span class="cl">indicate a one-byte-range starting at file offset zero, the required
</span></span><span class="line"><span class="cl">values of .start=0,.end=0 mean that the -&gt;writepages() implementation
</span></span><span class="line"><span class="cl">has no way of telling that it is being asked to perform a range
</span></span><span class="line"><span class="cl">request.  Because we&#39;re currently overloading (start == 0 &amp;&amp; end == 0)
</span></span><span class="line"><span class="cl">to mean &#34;this is not a write-a-range request&#34;.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">To make all this sane, the patch changes range of writeback_control.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">So caller does: If it is calling -&gt;writepages() to write pages, it
</span></span><span class="line"><span class="cl">sets range (range_start/end or range_cyclic) always.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">And if range_cyclic is true, -&gt;writepages() thinks the range is
</span></span><span class="line"><span class="cl">cyclic, otherwise it just uses range_start and range_end.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">This patch does,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - Add LLONG_MAX, LLONG_MIN, ULLONG_MAX to include/linux/kernel.h
</span></span><span class="line"><span class="cl">      -1 is usually ok for range_end (type is long long). But, if someone did,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		range_end += val;		range_end is &#34;val - 1&#34;
</span></span><span class="line"><span class="cl">		u64val = range_end &gt;&gt; bits;	u64val is &#34;~(0ULL)&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      or something, they are wrong. So, this adds LLONG_MAX to avoid nasty
</span></span><span class="line"><span class="cl">      things, and uses LLONG_MAX for range_end.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - All callers of -&gt;writepages() sets range_start/end or range_cyclic.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    - Fix updates of -&gt;writeback_index. It seems already bit strange.
</span></span><span class="line"><span class="cl">      If it starts at 0 and ended by check of nr_to_write, this last
</span></span><span class="line"><span class="cl">      index may reduce chance to scan end of file.  So, this updates
</span></span><span class="line"><span class="cl">      -&gt;writeback_index only if range_cyclic is true or whole-file is
</span></span><span class="line"><span class="cl">      scanned.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Signed-off-by: OGAWA Hirofumi &lt;hirofumi@mail.parknet.co.jp&gt;
</span></span><span class="line"><span class="cl">Cc: Nathan Scott &lt;nathans@sgi.com&gt;
</span></span><span class="line"><span class="cl">Cc: Anton Altaparmakov &lt;aia21@cantab.net&gt;
</span></span><span class="line"><span class="cl">Cc: Steven French &lt;sfrench@us.ibm.com&gt;
</span></span><span class="line"><span class="cl">Cc: &#34;Vladimir V. Saveliev&#34; &lt;vs@namesys.com&gt;
</span></span><span class="line"><span class="cl">Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
</span></span><span class="line"><span class="cl">Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;</span></span></code></pre></td></tr></table>
</div>
</div><p><code>range_cyclic</code> 和 <code>range_start/end</code> 互斥</p>
<ul>
<li>当开启 <code>range_cyclic</code> 将无视 <code>range_start/end</code> 的值</li>
<li>否则底层 <code>writepages</code> 函数则使用 <code>range_start/end</code> 作为写的范围</li>
</ul>
<div class="mermaid" id="id-14"></div><p>结合实际代码，在 <code>mm/page-writeback.c</code> 的 <code>write_cache_pages</code> 函数中有以下片段</p>
<div class="highlight" id="id-15"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_cyclic</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">writeback_index</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">writeback_index</span><span class="p">;</span> <span class="cm">/* prev offset */</span>
</span></span><span class="line"><span class="cl">		<span class="n">index</span> <span class="o">=</span> <span class="n">writeback_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">end</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">index</span> <span class="o">=</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">end</span> <span class="o">=</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_end</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_start</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_end</span> <span class="o">==</span> <span class="n">LLONG_MAX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="n">range_whole</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 此处省略部分代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * If we hit the last page and there is more work to be done: wrap
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * back the index back to the start of the file for the next
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * time we are called.
</span></span></span><span class="line"><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_cyclic</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">done</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">done_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_cyclic</span> <span class="o">||</span> <span class="p">(</span><span class="n">range_whole</span> <span class="o">&amp;&amp;</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">nr_to_write</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">writeback_index</span> <span class="o">=</span> <span class="n">done_index</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>range_cyclic</code> 开启后会使用 <code>mapping-&gt;writeback_index</code> 作为本次回写的起始地址，并会在完成本次回写流程（回写页数限制或者到达文件末尾）后更新 <code>mapping-&gt;writeback_index</code></p>
<h3 id="定期回写" class="heading-element">
  <a href="#%e5%ae%9a%e6%9c%9f%e5%9b%9e%e5%86%99" class="heading-mark"></a>定期回写</h3><p>定期回写的任务声明在 <code>fs/fs-writeback.c</code> 的 <code>wb_check_old_data_flush</code> 函数中，而这个函数则是被 <code>wb_workfn</code> 调用</p>
<div class="highlight" id="id-16"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">long</span> <span class="nf">wb_check_old_data_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">wb</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expired</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">long</span> <span class="n">nr_pages</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * When set to zero, disable periodic writeback
</span></span></span><span class="line"><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dirty_writeback_interval</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">expired</span> <span class="o">=</span> <span class="n">wb</span><span class="o">-&gt;</span><span class="n">last_old_flush</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">			<span class="nf">msecs_to_jiffies</span><span class="p">(</span><span class="n">dirty_writeback_interval</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">expired</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">wb</span><span class="o">-&gt;</span><span class="n">last_old_flush</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">nr_pages</span> <span class="o">=</span> <span class="nf">get_nr_dirty_pages</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 定期回写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">struct</span> <span class="n">wb_writeback_work</span> <span class="n">work</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="p">.</span><span class="n">nr_pages</span>	<span class="o">=</span> <span class="n">nr_pages</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="p">.</span><span class="n">sync_mode</span>	<span class="o">=</span> <span class="n">WB_SYNC_NONE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="p">.</span><span class="n">for_kupdate</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="p">.</span><span class="n">range_cyclic</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="p">.</span><span class="n">reason</span>		<span class="o">=</span> <span class="n">WB_REASON_PERIODIC</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nf">wb_writeback</span><span class="p">(</span><span class="n">wb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="mermaid" id="id-17"></div><p>首先要保证当前时间在上次定期回写的 5s （和定期唤醒的时间间隔一致）后，并且当前存在脏页，才会生成一次定期回写的任务，也就是说每 5s 内最多触发一次定期回写</p>
<p>生成的回写任务交给 <code>fs/fs-writeback.c</code> 的 <code>wb_writeback</code> 函数处理</p>
<p>并且定期回写属于一种后台回写，优先级较低，只有在 <code>wb-&gt;work_list</code> 为空时才会执行</p>
<p><code>wb_writeback</code> 执行定期回写时只会选择在至脏时间在当前时间 30s 之前的 <code>inode</code> 的所有脏页进行回写</p>
<h3 id="阈值回写" class="heading-element">
  <a href="#%e9%98%88%e5%80%bc%e5%9b%9e%e5%86%99" class="heading-mark"></a>阈值回写</h3><p>针对脏页率内核中有两个阈值，10% 和 20%</p>
<div class="highlight" id="id-18"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// mm/page-writeback.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Start background writeback (via writeback threads) at this percentage
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">dirty_background_ratio</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm"> * The generator of dirty data starts writeback at this percentage
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">vm_dirty_ratio</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li>
<p>bg_thresh 后台阈值</p>
<p>当脏页率达到 10% 时会以后台的方式进行回写</p>
<div class="mermaid" id="id-19"></div><p>当用户 <code>write</code> 调用使用 <code>generic_perform_write</code> 来写 page cache 时，会调用 <code>balance_dirty_pages_ratelimited</code> 来检查脏页率，当脏页率超过 10% 就会调用 <code>balance_dirty_pages</code> 来唤醒 <code>wb_workfn</code> 来进行下刷脏页，此时并不会阻塞当前的 <code>write</code> 过程</p>
</li>
<li>
<p>thresh 前台阈值</p>
<p>而当脏页率达到 20% 之后则会触发前台回写，此时的函数调用和逻辑和上面基本一致，不同点在于当脏页率超过 20% 后会在 <code>balance_dirty_pages</code> 的循环中无法跳出，因此线程会阻塞，直到脏页率降低至 20% 以下，跳出循环，启用后台回写</p>
</li>
</ol>
<h2 id="手动触发回写" class="heading-element">
  <a href="#%e6%89%8b%e5%8a%a8%e8%a7%a6%e5%8f%91%e5%9b%9e%e5%86%99" class="heading-mark"></a>手动触发回写</h2><h3 id="sync" class="heading-element">
  <a href="#sync" class="heading-mark"></a><code>sync</code></h3><p><code>sync</code> 系统调用会同步所有的 page cache</p>
<p>在 <code>bash</code> 上直接输入 <code>sync</code> 命令就会触发 <code>sync</code> 系统调用</p>
<div class="highlight" id="id-20"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// fs/sync.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Sync everything. We start by waking flusher threads so that most of
</span></span></span><span class="line"><span class="cl"><span class="cm"> * writeback runs on all devices in parallel. Then we sync all inodes reliably
</span></span></span><span class="line"><span class="cl"><span class="cm"> * which effectively also waits for all flusher threads to finish doing
</span></span></span><span class="line"><span class="cl"><span class="cm"> * writeback. At this point all data is on disk so metadata should be stable
</span></span></span><span class="line"><span class="cl"><span class="cm"> * and we tell filesystems to sync their metadata via -&gt;sync_fs() calls.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Finally, we writeout all block devices because some filesystems (e.g. ext2)
</span></span></span><span class="line"><span class="cl"><span class="cm"> * just write metadata (such as inodes or bitmaps) to block device page cache
</span></span></span><span class="line"><span class="cl"><span class="cm"> * and do not sync it on their own in -&gt;sync_fs().
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">ksys_sync</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">nowait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">wait</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 唤醒所有 bdi 的回写线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">wakeup_flusher_threads</span><span class="p">(</span><span class="n">WB_REASON_SYNC</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 下发所有 inode 的回写任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">iterate_supers</span><span class="p">(</span><span class="n">sync_inodes_one_sb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 调用 sync_fs() 同步文件系统的元数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">iterate_supers</span><span class="p">(</span><span class="n">sync_fs_one_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nowait</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">iterate_supers</span><span class="p">(</span><span class="n">sync_fs_one_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 回写块设备的 page cache
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">iterate_bdevs</span><span class="p">(</span><span class="n">fdatawrite_one_bdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">iterate_bdevs</span><span class="p">(</span><span class="n">fdatawait_one_bdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="n">laptop_mode</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nf">laptop_sync_completion</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">SYSCALL_DEFINE0</span><span class="p">(</span><span class="n">sync</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">ksys_sync</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>首先，唤醒所有设备的回写线程线程，这样大部分的回写在所有设备上并行运行</li>
<li>并立刻生成一个下刷设备上所有 inode 的回写任务，并等待完成</li>
<li>然后文件系统通过注册的 <code>sync_fs()</code> 调用来同步他们的元数据</li>
<li>最后，回写所有的块设备的 page cache
<ul>
<li>因为有些文件系统（例如 <code>ext2</code>）会将元数据（如 <code>inodes</code> 或 <code>bitmaps</code>）写入块设备 page cache，而不是在 <code>sync_fs()</code> 中自行同步</li>
</ul>
</li>
</ul>
<h3 id="fsync-和-fdatasync" class="heading-element">
  <a href="#fsync-%e5%92%8c-fdatasync" class="heading-mark"></a><code>fsync</code> 和 <code>fdatasync</code></h3><p><code>fsync</code> 和 <code>fdatasync</code> 系统调用则可以更加细粒度的下刷脏页，他们的下刷对象是一个文件</p>
<div class="highlight" id="id-21"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// fs/sync.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * vfs_fsync_range - helper to sync a range of data &amp; metadata to disk
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @file:		file to sync
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @start:		offset in bytes of the beginning of data range to sync
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @end:		offset in bytes of the end of data range (inclusive)
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @datasync:		perform only datasync
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Write back data in range @start..@end and metadata for @file to disk.  If
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @datasync is set only metadata needed to access modified file data is
</span></span></span><span class="line"><span class="cl"><span class="cm"> * written.
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">vfs_fsync_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="kt">loff_t</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="n">datasync</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">fsync</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">datasync</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_DIRTY_TIME</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nf">mark_inode_dirty_sync</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="nf">fsync</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">datasync</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nf">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vfs_fsync_range</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * vfs_fsync - perform a fsync or fdatasync on a file
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @file:		file to sync
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @datasync:		only perform a fdatasync operation
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Write back data and metadata for @file to disk.  If @datasync is
</span></span></span><span class="line"><span class="cl"><span class="cm"> * set only metadata needed to access modified file data is written.
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">vfs_fsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">datasync</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">vfs_fsync_range</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LLONG_MAX</span><span class="p">,</span> <span class="n">datasync</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nf">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vfs_fsync</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">do_fsync</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">datasync</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">fd</span> <span class="n">f</span> <span class="o">=</span> <span class="nf">fdget</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">ret</span> <span class="o">=</span> <span class="nf">vfs_fsync</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">file</span><span class="p">,</span> <span class="n">datasync</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="nf">fdput</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">fsync</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">do_fsync</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">fdatasync</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">do_fsync</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>fsync</code> 和 <code>fdatasync</code> 会调用文件系统注册的 <code>f_op-&gt;fsync()</code> 函数进行脏页的下刷。很多文件系统会使用或者参考通用的 <code>generic_file_fsync</code> 来实现，这里针对 <code>__generic_file_fsync</code> 进行分析</p>
<div class="highlight" id="id-22"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// fs/libfs.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * __generic_file_fsync - generic fsync implementation for simple filesystems
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @file:	file to synchronize
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @start:	start offset in bytes
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @end:	end offset in bytes (inclusive)
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @datasync:	only synchronize essential metadata if true
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * This is a generic implementation of the fsync method for simple
</span></span></span><span class="line"><span class="cl"><span class="cm"> * filesystems which track all non-inode metadata in the buffers list
</span></span></span><span class="line"><span class="cl"><span class="cm"> * hanging off the address_space structure.
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">__generic_file_fsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="kt">loff_t</span> <span class="n">end</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">				 <span class="kt">int</span> <span class="n">datasync</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">err</span> <span class="o">=</span> <span class="nf">file_write_and_wait_range</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">inode_lock</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">ret</span> <span class="o">=</span> <span class="nf">sync_mapping_buffers</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_DIRTY_ALL</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">datasync</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_DIRTY_DATASYNC</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">err</span> <span class="o">=</span> <span class="nf">sync_inode_metadata</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">out</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="nf">inode_unlock</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/* check and advance again to catch errors after syncing out buffers */</span>
</span></span><span class="line"><span class="cl">	<span class="n">err</span> <span class="o">=</span> <span class="nf">file_check_and_advance_wb_err</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nf">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__generic_file_fsync</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * generic_file_fsync - generic fsync implementation for simple filesystems
</span></span></span><span class="line"><span class="cl"><span class="cm"> *			with flush
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @file:	file to synchronize
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @start:	start offset in bytes
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @end:	end offset in bytes (inclusive)
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @datasync:	only synchronize essential metadata if true
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">generic_file_fsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="kt">loff_t</span> <span class="n">end</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		       <span class="kt">int</span> <span class="n">datasync</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">err</span> <span class="o">=</span> <span class="nf">__generic_file_fsync</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">datasync</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">blkdev_issue_flush</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nf">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">generic_file_fsync</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>无论 <code>fsync</code> 还是 <code>fdatasync</code> 都会调用 <code>file_write_and_wait_range</code> 下刷 page cache 中的脏页。而在 indoe 本身元数据只是时间戳是脏时，<code>fdatasync</code> 就会跳过 <code>sync_inode_metadata</code>，不将元数据一起下刷到底层设备上；<code>fsync</code> 则不会跳过元数据的下刷。</p>
<p>因此 <code>fsync</code> 至少需要两次 IO 写操作，开销比 <code>fdatasync</code> 更大</p>
<h3 id="open-时带有-o_sync" class="heading-element">
  <a href="#open-%e6%97%b6%e5%b8%a6%e6%9c%89-o_sync" class="heading-mark"></a><code>open</code> 时带有 <code>O_SYNC</code></h3><p>如果在打开一个文件时带了 <code>O_SYNC</code> 标记，则会在写入 page cache 后，再次调用 <code>vfs_fsync_range</code> 将数据下刷到底层设备上</p>
<div class="mermaid" id="id-23"></div><p>在 <code>ext4</code>、<code>f2fs</code> 等文件系统 <code>write</code> 系统调用会使用 <code>new_sync_write</code> 来调用实际文件系统注册的 <code>read_iter</code> 函数</p>
<p>而 <code>new_sync_write</code> 调用先调用 <code>iocb_flags</code> 将用户配置的 <code>O_SYNC</code> 进行解析，为 <code>struct kiocb</code> 的 <code>ki_flags</code> 字段生成标记</p>
<div class="mermaid" id="id-24"></div><p>和之前一样，大多数文件系统会直接使用或者参考通用的 <code>generic_file_write_iter</code> 来实现 <code>read_iter</code> 函数，这里针对 <code>generic_file_write_iter</code> 进行分析</p>
<div class="highlight" id="id-25"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// mm/filemap.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * generic_file_write_iter - write data to a file
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @iocb:	IO state structure
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @from:	iov_iter with data to write
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * This is a wrapper around __generic_file_write_iter() to be used by most
</span></span></span><span class="line"><span class="cl"><span class="cm"> * filesystems. It takes care of syncing the file in case of O_SYNC file
</span></span></span><span class="line"><span class="cl"><span class="cm"> * and acquires i_mutex as needed.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Return:
</span></span></span><span class="line"><span class="cl"><span class="cm"> * * negative error code if no data has been written at all of
</span></span></span><span class="line"><span class="cl"><span class="cm"> *   vfs_fsync_range() failed for a synchronous write
</span></span></span><span class="line"><span class="cl"><span class="cm"> * * number of bytes written, even for truncated writes
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">ssize_t</span> <span class="nf">generic_file_write_iter</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">from</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">inode_lock</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">ret</span> <span class="o">=</span> <span class="nf">generic_write_checks</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">from</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">ret</span> <span class="o">=</span> <span class="nf">__generic_file_write_iter</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">from</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">inode_unlock</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">ret</span> <span class="o">=</span> <span class="nf">generic_write_sync</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nf">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">generic_file_write_iter</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在 <code>__generic_file_write_iter</code> 完成之后，实际的数据已经被写入 page cache，之后会调用 <code>generic_write_sync</code> 会将刚刚写入 page cache 的数据通过 <code>vfs_fsync_range</code> 下刷到底层设备上</p>
<div class="highlight" id="id-26"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// include/linux/fs.h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Sync the bytes written if this was a synchronous write.  Expect ki_pos
</span></span></span><span class="line"><span class="cl"><span class="cm"> * to already be updated for the write, and will return either the amount
</span></span></span><span class="line"><span class="cl"><span class="cm"> * of bytes passed in, or an error if syncing the file failed.
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">ssize_t</span> <span class="nf">generic_write_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="kt">ssize_t</span> <span class="n">count</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_flags</span> <span class="o">&amp;</span> <span class="n">IOCB_DSYNC</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="nf">vfs_fsync_range</span><span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">				<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span> <span class="o">-</span> <span class="n">count</span><span class="p">,</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">				<span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_flags</span> <span class="o">&amp;</span> <span class="n">IOCB_SYNC</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考资料" class="heading-element">
  <a href="#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99" class="heading-mark"></a>参考资料</h2><ul>
<li><a href="https://blog.csdn.net/jasonactions/article/details/117292233"target="_blank" rel="external nofollow noopener noreferrer">【CSDN】VFS 基础学习笔记 - 7. page cache 回写</a></li>
<li><a href="https://blog.csdn.net/u011649400/article/details/96505600"target="_blank" rel="external nofollow noopener noreferrer">【CSDN】VFS 源码分析 - Page Cache Writeback 脏页回写机制</a></li>
<li>以及在评论区的某位不愿透露姓名的 dalao 的笔记</li>
</ul>
</div><div class="post-copyright">
    <ul>
        <li class="post-copyright-author">
            <strong>本文作者：</strong>
            
        </li>
        <li class="post-copyright-link">
            <strong>本文链接：</strong>
            <a href="https://ywang-wnlo.github.io/posts/646202b9/" title="page cache 回写机制">https://ywang-wnlo.github.io/posts/646202b9/</a>
        </li>
        <li class="post-copyright-license">
            <strong>版权声明：</strong>
            本博客所有文章除特别声明外，均采用 <a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div><h2 id="see-also">相关内容</h2>
    <ul><li>
          <a href="/posts/9ba60726/" title="page cache 简介">page cache 简介</a></li><li>
          <a href="/posts/2c65e859/" title="个人简历相关的基础知识梳理">个人简历相关的基础知识梳理</a></li><li>
          <a href="/posts/4f0d345c/" title="io_uring 内核源码分析">io_uring 内核源码分析</a></li></ul><div class="post-reward">
    <div class="comment">请我一杯咖啡吧！</div>
    <input type="checkbox" class="reward-input" name="reward" id="fi-reward" hidden />
    <label class="reward-button" for="fi-reward">赞赏</label>
    <div class="reward-ways" data-mode="static"><div><img loading="lazy" src="/images/alipay.jpg" alt="Zeus 支付宝" data-title="Zeus 支付宝" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/><span>支付宝</span>
          </div><div><img loading="lazy" src="/images/wechatpay.png" alt="Zeus 微信" data-title="Zeus 微信" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/><span>微信</span>
          </div></div>
  </div><div class="post-footer" id="post-footer">
  <div class="post-info">
    <div class="post-info-line">
      <div class="post-info-mod">
        <span title="更新于 2022-11-16 10:33:39">更新于 2022-11-16&nbsp;</span>
      </div><div class="post-info-license">
            <span><a rel="license external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA 4.0</a></span>
          </div></div><div class="post-info-line">
        <div class="post-info-md"><span><a href="/posts/646202b9/index.md" title="阅读原始文档" class="link-to-markdown">阅读原始文档</a></span></div>
        <div class="post-info-share">
          <span></span>
        </div>
      </div></div>

  <div class="post-info-more">
    <section class="post-tags"><i class="fa-solid fa-tags fa-fw me-1" aria-hidden="true"></i><a href="/tags/page-cache/" class="post-tag" title="标签 - page cache">page cache</a><a href="/tags/buffer-io/" class="post-tag" title="标签 - buffer IO">buffer IO</a><a href="/tags/kernel/" class="post-tag" title="标签 - kernel">kernel</a><a href="/tags/writeback/" class="post-tag" title="标签 - writeback">writeback</a></section>
    <section>
      <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
    </section>
  </div>

  <div class="post-nav"><a href="/posts/96a1807/" class="post-nav-item" rel="prev" title="OpenWrt 手动编译 ipk"><i class="fa-solid fa-angle-left fa-fw" aria-hidden="true"></i>OpenWrt 手动编译 ipk</a>
      <a href="/posts/4143201a/" class="post-nav-item" rel="next" title="Hexo 插件推荐以及使用小技巧">Hexo 插件推荐以及使用小技巧<i class="fa-solid fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
<div id="comments"><div id="giscus">
          <script
            src="https://giscus.app/client.js"
            data-repo="ywang-wnlo/ywang-wnlo.github.io"
            data-repo-id="R_kgDOGTSTcQ"
            data-category="announcements"
            data-category-id="DIC_kwDOGTSTcc4CZaXg"
            data-mapping="pathname"
            data-strict="0"
            
            data-theme="preferred_color_scheme"
            data-reactions-enabled="1"
            data-emit-metadata="0"
            data-input-position="bottom"
            data-lang="zh-CN"
            data-loading="lazy"
            crossorigin="anonymous"
            async
            defer
          ></script>
        </div>
        <noscript>
          Please enable JavaScript to view the comments powered by <a href="https://giscus.app/" rel="external nofollow noopener noreferrer">giscus</a>.
        </noscript></div></article>

  <aside class="toc" id="toc-auto" aria-label="目录"><h2 class="toc-title">目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden="true"></i></h2>
      <div class="toc-content" id="toc-content-auto"></div></aside></main><footer class="footer">
    <div class="footer-container"><div class="footer-line powered">由 <a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreferrer" title="Hugo 0.118.2">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/hugo-fixit/FixIt" target="_blank" rel="external" title="FixIt v0.3.1">FixIt</a>
        </div><div class="footer-line copyright" itemscope itemtype="http://schema.org/CreativeWork"><i class="fa-regular fa-copyright fa-fw" aria-hidden="true"></i>
            <span itemprop="copyrightYear">2021 - 2024</span><span class="author" itemprop="copyrightHolder">
              <a href="https://github.com/ywang-wnlo"target="_blank" rel="external nofollow noopener noreferrer">Zeus</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA 4.0</a></span></div><div class="footer-line visitor">
          <span id="busuanzi_container_site_uv" title='总访客数'><i class="fa-regular fa-user fa-fw" aria-hidden="true"></i>&nbsp;<span id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span></span><span id="busuanzi_container_site_pv" class="footer-divider" title='总访问量'><i class="fa-regular fa-eye fa-fw" aria-hidden="true"></i>&nbsp;<span id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span></span>
        </div></div>
  </footer></div><div class="widgets"><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role="button" aria-label="回到顶部"><i class="fa-solid fa-arrow-up fa-fw" aria-hidden="true"></i><span class="variant-numeric d-none">0%</span>
        </div><div class="fixed-button view-comments d-none" role="button" aria-label="查看评论"><i class="fa-solid fa-comment fa-fw" aria-hidden="true"></i></div></div><div id="mask"></div><div class="reading-progress-bar" style="left: 0;top: 0;"></div><noscript>
    <div class="noscript-warning">FixIt 主题在启用 JavaScript 的情况下效果最佳。</div>
  </noscript>
</div><link rel="stylesheet" href="https://unpkg.com/lightgallery@2.7.2/css/lightgallery-bundle.min.css"><link rel="preload" href="https://unpkg.com/katex@0.16.9/dist/katex.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="https://unpkg.com/katex@0.16.9/dist/katex.min.css"></noscript><link rel="stylesheet" href="https://unpkg.com/pace-js@1.2.4/themes/silver/pace-theme-minimal.css"><script src="https://unpkg.com/autocomplete.js@0.38.1/dist/autocomplete.min.js" defer></script><script src="https://unpkg.com/fuse.js@6.6.2/dist/fuse.min.js" defer></script><script src="https://unpkg.com/lightgallery@2.7.2/lightgallery.min.js" defer></script><script src="https://unpkg.com/lightgallery@2.7.2/plugins/thumbnail/lg-thumbnail.min.js" defer></script><script src="https://unpkg.com/lightgallery@2.7.2/plugins/zoom/lg-zoom.min.js" defer></script><script src="https://unpkg.com/katex@0.16.9/dist/katex.min.js" defer></script><script src="https://unpkg.com/katex@0.16.9/dist/contrib/auto-render.min.js" defer></script><script src="https://unpkg.com/katex@0.16.9/dist/contrib/copy-tex.min.js" defer></script><script src="https://unpkg.com/katex@0.16.9/dist/contrib/mhchem.min.js" defer></script><script src="https://unpkg.com/mermaid@9.4.3/dist/mermaid.min.js"></script><script src="https://unpkg.com/pangu@4.0.7/dist/browser/pangu.min.js" defer></script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async defer></script><script src="https://unpkg.com/pace-js@1.2.4/pace.min.js" async defer></script><script>window.config={"autoBookmark":true,"code":{"copyTitle":"复制到剪贴板","editLockTitle":"锁定可编辑代码块","editUnLockTitle":"解锁可编辑代码块","editable":true,"maxShownLines":50},"comment":{"enable":true,"expired":false,"giscus":{"darkTheme":"dark_dimmed","lightTheme":"light"}},"data":{"id-10":"graph TD\nrelease_bdi --\u003e bdi_unregister --\u003e wb_shutdown\nrelease_bdi ---\u003e wb_exit","id-14":"graph TD\ndo_writepages --\u003e writepages(\"mapping-\u003ea_ops-\u003ewritepages()\")\ndo_writepages --\u003e generic_writepages --\u003e write_cache_pages","id-17":"graph TD\nwb_wakeup -.-\u003e wb_workfn --\u003e|通常情况| wb_do_writeback --\u003e wb_check_old_data_flush","id-19":"graph TD\ngeneric_perform_write --\u003e balance_dirty_pages_ratelimited --\u003e balance_dirty_pages --\u003e wb_start_background_writeback --\u003e wb_wakeup\nwb_wakeup -.-\u003e wb_workfn --\u003e|通常情况| wb_do_writeback --\u003e|wb_over_bg_thresh| wb_check_background_flush","id-23":"graph LR\nwrite系统调用 --\u003e ksys_write --\u003e vfs_write --\u003e __vfs_write --\u003e|ext4,f2fs等文件系统| new_sync_write","id-24":"graph TD\nnew_sync_write --\u003e init_sync_kiocb --\u003e iocb_flags\nnew_sync_write --\u003e iov_iter_init\nnew_sync_write --\u003e call_write_iter","id-3":"graph TD\nbdi_init --\u003e cgwb_bdi_init --\u003e wb_init"},"lightgallery":true,"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"mermaid":{"themes":["default","dark"]},"pangu":{"enable":true,"selector":"article"},"search":{"distance":100,"findAllMatches":false,"fuseIndexURL":"/index.json","highlightTag":"em","ignoreFieldNorm":false,"ignoreLocation":false,"isCaseSensitive":false,"location":0,"maxResultLength":10,"minMatchCharLength":2,"noResultsFound":"没有找到结果","snippetLength":30,"threshold":0.3,"type":"fuse","useExtendedSearch":false}};</script><script src="/js/theme.min.js" defer></script></body>
</html>
